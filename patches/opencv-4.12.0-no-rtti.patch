diff -Nuarp opencv-4.12.0-orig/modules/core/include/opencv2/core/bindings_utils.hpp opencv-4.12.0-no-rtti-manual/modules/core/include/opencv2/core/bindings_utils.hpp
--- opencv-4.12.0-orig/modules/core/include/opencv2/core/bindings_utils.hpp	2025-07-13 06:04:01.145783391 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/include/opencv2/core/bindings_utils.hpp	2025-07-13 06:09:23.172181009 +0000
@@ -202,12 +202,6 @@ void generateVectorOfMat(size_t len, int
 }
 
 CV_WRAP static inline
-void testRaiseGeneralException()
-{
-    throw std::runtime_error("exception text");
-}
-
-CV_WRAP static inline
 AsyncArray testAsyncArray(InputArray argument)
 {
     AsyncPromise p;
@@ -219,14 +213,6 @@ CV_WRAP static inline
 AsyncArray testAsyncException()
 {
     AsyncPromise p;
-    try
-    {
-        CV_Error(Error::StsOk, "Test: Generated async error");
-    }
-    catch (const cv::Exception& e)
-    {
-        p.setException(e);
-    }
     return p.getArrayResult();
 }
 
diff -Nuarp opencv-4.12.0-orig/modules/core/src/async.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/async.cpp
--- opencv-4.12.0-orig/modules/core/src/async.cpp	2025-07-13 06:04:01.161783454 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/async.cpp	2025-07-13 06:09:23.172181009 +0000
@@ -108,7 +108,6 @@ struct AsyncArray::Impl
             if (has_exception)
             {
                 result_is_fetched = true;
-                throw cv_exception;
             }
             CV_Error(Error::StsInternal, "AsyncArray: invalid state of 'has_result = true'");
         }
@@ -287,7 +286,6 @@ struct AsyncArray::Impl
         if (has_exception)
         {
             result_is_fetched = true;
-            throw cv_exception;
         }
         CV_Error(Error::StsInternal, "AsyncArray: invalid state of 'has_result = true'");
         return false;
diff -Nuarp opencv-4.12.0-orig/modules/core/src/async.cpp.orig opencv-4.12.0-no-rtti-manual/modules/core/src/async.cpp.orig
--- opencv-4.12.0-orig/modules/core/src/async.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/async.cpp.orig	2025-07-13 06:09:16.034149681 +0000
@@ -0,0 +1,499 @@
+// This file is part of OpenCV project.
+// It is subject to the license terms in the LICENSE file found in the top-level directory
+// of this distribution and at http://opencv.org/license.html.
+
+#include "precomp.hpp"
+#include "opencv2/core/async.hpp"
+#include "opencv2/core/detail/async_promise.hpp"
+
+#include "opencv2/core/cvstd.hpp"
+
+#include <opencv2/core/utils/logger.defines.hpp>
+#undef CV_LOG_STRIP_LEVEL
+#define CV_LOG_STRIP_LEVEL CV_LOG_LEVEL_DEBUG + 1
+#include <opencv2/core/utils/logger.hpp>
+
+#ifndef OPENCV_DISABLE_THREAD_SUPPORT
+
+#include <mutex>
+#include <condition_variable>
+#include <chrono>
+
+namespace cv {
+
+/**
+Manages shared state of asynchronous result
+*/
+struct AsyncArray::Impl
+{
+    int refcount;
+    void addrefFuture() CV_NOEXCEPT { CV_XADD(&refcount_future, 1); CV_XADD(&refcount, 1); } \
+    void releaseFuture() CV_NOEXCEPT { CV_XADD(&refcount_future, -1); if(1 == CV_XADD(&refcount, -1)) delete this; } \
+    int refcount_future;
+    void addrefPromise() CV_NOEXCEPT { CV_XADD(&refcount_promise, 1); CV_XADD(&refcount, 1); } \
+    void releasePromise() CV_NOEXCEPT { CV_XADD(&refcount_promise, -1); if(1 == CV_XADD(&refcount, -1)) delete this; } \
+    int refcount_promise;
+
+    mutable std::mutex mtx;
+    mutable std::condition_variable cond_var;
+
+    mutable bool has_result; // Mat, UMat or exception
+
+    mutable cv::Ptr<Mat> result_mat;
+    mutable cv::Ptr<UMat> result_umat;
+
+
+    bool has_exception;
+#if CV__EXCEPTION_PTR
+    std::exception_ptr exception;
+#endif
+    cv::Exception cv_exception;
+
+    mutable bool result_is_fetched;
+
+    bool future_is_returned;
+
+    Impl()
+        : refcount(1), refcount_future(0), refcount_promise(1)
+        , has_result(false)
+        , has_exception(false)
+        , result_is_fetched(false)
+        , future_is_returned(false)
+    {
+        // nothing
+    }
+
+    ~Impl()
+    {
+        if (has_result && !result_is_fetched)
+        {
+            CV_LOG_INFO(NULL, "Asynchronous result has not been fetched");
+        }
+    }
+
+    bool get(OutputArray dst, int64 timeoutNs) const
+    {
+        CV_Assert(!result_is_fetched);
+        if (!has_result)
+        {
+            if(refcount_promise == 0)
+                CV_Error(Error::StsInternal, "Asynchronous result producer has been destroyed");
+            if (!wait_for(timeoutNs))
+                return false;
+        }
+        std::unique_lock<std::mutex> lock(mtx);
+        if (has_result)
+        {
+            if (!result_mat.empty())
+            {
+                dst.move(*result_mat.get());
+                result_mat.release();
+                result_is_fetched = true;
+                return true;
+            }
+            if (!result_umat.empty())
+            {
+                dst.move(*result_umat.get());
+                result_umat.release();
+                result_is_fetched = true;
+                return true;
+            }
+#if CV__EXCEPTION_PTR
+            if (has_exception && exception)
+            {
+                result_is_fetched = true;
+                std::rethrow_exception(exception);
+            }
+#endif
+            if (has_exception)
+            {
+                result_is_fetched = true;
+                throw cv_exception;
+            }
+            CV_Error(Error::StsInternal, "AsyncArray: invalid state of 'has_result = true'");
+        }
+        CV_Assert(!has_result);
+        CV_Assert(timeoutNs < 0);
+        return false;
+    }
+
+    bool valid() const CV_NOEXCEPT
+    {
+        if (result_is_fetched)
+            return false;
+        if (refcount_promise == 0 && !has_result)
+            return false;
+        return true;
+    }
+
+    bool wait_for(int64 timeoutNs) const
+    {
+        CV_Assert(valid());
+        if (has_result)
+            return has_result;
+        if (timeoutNs == 0)
+            return has_result;
+        CV_LOG_INFO(NULL, "Waiting for async result ...");
+        std::unique_lock<std::mutex> lock(mtx);
+        const auto cond_pred = [&]{ return has_result == true; };
+        if (timeoutNs > 0)
+            return cond_var.wait_for(lock, std::chrono::nanoseconds(timeoutNs), cond_pred);
+        else
+        {
+            cond_var.wait(lock, cond_pred);
+            CV_Assert(has_result);
+            return true;
+        }
+    }
+
+    AsyncArray getArrayResult()
+    {
+        CV_Assert(refcount_future == 0);
+        AsyncArray result;
+        addrefFuture();
+        result.p = this;
+        future_is_returned = true;
+        return result;
+    }
+
+    void setValue(InputArray value)
+    {
+        if (future_is_returned && refcount_future == 0)
+            CV_Error(Error::StsError, "Associated AsyncArray has been destroyed");
+        std::unique_lock<std::mutex> lock(mtx);
+        CV_Assert(!has_result);
+        int k = value.kind();
+        if (k == _InputArray::UMAT)
+        {
+            result_umat = makePtr<UMat>();
+            value.copyTo(*result_umat.get());
+        }
+        else
+        {
+            result_mat = makePtr<Mat>();
+            value.copyTo(*result_mat.get());
+        }
+        has_result = true;
+        cond_var.notify_all();
+    }
+
+#if CV__EXCEPTION_PTR
+    void setException(std::exception_ptr e)
+    {
+        if (future_is_returned && refcount_future == 0)
+            CV_Error(Error::StsError, "Associated AsyncArray has been destroyed");
+        std::unique_lock<std::mutex> lock(mtx);
+        CV_Assert(!has_result);
+        has_exception = true;
+        exception = e;
+        has_result = true;
+        cond_var.notify_all();
+    }
+#endif
+
+    void setException(const cv::Exception e)
+    {
+        if (future_is_returned && refcount_future == 0)
+            CV_Error(Error::StsError, "Associated AsyncArray has been destroyed");
+        std::unique_lock<std::mutex> lock(mtx);
+        CV_Assert(!has_result);
+        has_exception = true;
+        cv_exception = e;
+        has_result = true;
+        cond_var.notify_all();
+    }
+};
+
+}  // namespace
+
+#else  // OPENCV_DISABLE_THREAD_SUPPORT
+
+namespace cv {
+
+// no threading
+struct AsyncArray::Impl
+{
+    int refcount;
+    void addrefFuture() CV_NOEXCEPT { refcount_future++; refcount++; }
+    void releaseFuture() CV_NOEXCEPT { refcount_future--; if (0 == --refcount) delete this; }
+    int refcount_future;
+    void addrefPromise() CV_NOEXCEPT { refcount_promise++; refcount++; } \
+    void releasePromise() CV_NOEXCEPT { refcount_promise--; if (0 == --refcount) delete this; }
+    int refcount_promise;
+
+    mutable bool has_result; // Mat, UMat or exception
+
+    mutable cv::Ptr<Mat> result_mat;
+    mutable cv::Ptr<UMat> result_umat;
+
+
+    bool has_exception;
+#if CV__EXCEPTION_PTR
+    std::exception_ptr exception;
+#endif
+    cv::Exception cv_exception;
+
+    mutable bool result_is_fetched;
+
+    bool future_is_returned;
+
+    Impl()
+        : refcount(1), refcount_future(0), refcount_promise(1)
+        , has_result(false)
+        , has_exception(false)
+        , result_is_fetched(false)
+        , future_is_returned(false)
+    {
+        // nothing
+    }
+
+    ~Impl()
+    {
+        if (has_result && !result_is_fetched)
+        {
+            CV_LOG_INFO(NULL, "Asynchronous result has not been fetched");
+        }
+    }
+
+    bool get(OutputArray dst, int64 timeoutNs) const
+    {
+        CV_Assert(!result_is_fetched);
+        if (!has_result)
+        {
+            CV_UNUSED(timeoutNs);
+            CV_Error(Error::StsError, "Result is not produced (unable to wait for result in OPENCV_DISABLE_THREAD_SUPPORT mode)");
+        }
+        if (!result_mat.empty())
+        {
+            dst.move(*result_mat.get());
+            result_mat.release();
+            result_is_fetched = true;
+            return true;
+        }
+        if (!result_umat.empty())
+        {
+            dst.move(*result_umat.get());
+            result_umat.release();
+            result_is_fetched = true;
+            return true;
+        }
+#if CV__EXCEPTION_PTR
+        if (has_exception && exception)
+        {
+            result_is_fetched = true;
+            std::rethrow_exception(exception);
+        }
+#endif
+        if (has_exception)
+        {
+            result_is_fetched = true;
+            throw cv_exception;
+        }
+        CV_Error(Error::StsInternal, "AsyncArray: invalid state of 'has_result = true'");
+        return false;
+    }
+
+    bool valid() const CV_NOEXCEPT
+    {
+        if (result_is_fetched)
+            return false;
+        if (refcount_promise == 0 && !has_result)
+            return false;
+        return true;
+    }
+
+    bool wait_for(int64 timeoutNs) const
+    {
+        CV_Assert(valid());
+        if (has_result)
+            return has_result;
+        if (timeoutNs == 0)
+            return has_result;
+        CV_Error(Error::StsError, "Unable to wait in OPENCV_DISABLE_THREAD_SUPPORT mode");
+    }
+
+    AsyncArray getArrayResult()
+    {
+        CV_Assert(refcount_future == 0);
+        AsyncArray result;
+        addrefFuture();
+        result.p = this;
+        future_is_returned = true;
+        return result;
+    }
+
+    void setValue(InputArray value)
+    {
+        if (future_is_returned && refcount_future == 0)
+            CV_Error(Error::StsError, "Associated AsyncArray has been destroyed");
+        CV_Assert(!has_result);
+        int k = value.kind();
+        if (k == _InputArray::UMAT)
+        {
+            result_umat = makePtr<UMat>();
+            value.copyTo(*result_umat.get());
+        }
+        else
+        {
+            result_mat = makePtr<Mat>();
+            value.copyTo(*result_mat.get());
+        }
+        has_result = true;
+    }
+
+#if CV__EXCEPTION_PTR
+    void setException(std::exception_ptr e)
+    {
+        if (future_is_returned && refcount_future == 0)
+            CV_Error(Error::StsError, "Associated AsyncArray has been destroyed");
+        CV_Assert(!has_result);
+        has_exception = true;
+        exception = e;
+        has_result = true;
+    }
+#endif
+
+    void setException(const cv::Exception e)
+    {
+        if (future_is_returned && refcount_future == 0)
+            CV_Error(Error::StsError, "Associated AsyncArray has been destroyed");
+        CV_Assert(!has_result);
+        has_exception = true;
+        cv_exception = e;
+        has_result = true;
+    }
+};
+
+}
+
+#endif  // OPENCV_DISABLE_THREAD_SUPPORT
+
+namespace cv {
+
+AsyncArray::AsyncArray() CV_NOEXCEPT
+    : p(NULL)
+{
+}
+
+AsyncArray::~AsyncArray() CV_NOEXCEPT
+{
+    release();
+}
+
+AsyncArray::AsyncArray(const AsyncArray& o) CV_NOEXCEPT
+    : p(o.p)
+{
+    if (p)
+        p->addrefFuture();
+}
+
+AsyncArray& AsyncArray::operator=(const AsyncArray& o) CV_NOEXCEPT
+{
+    Impl* newp = o.p;
+    if (newp)
+        newp->addrefFuture();
+    release();
+    p = newp;
+    return *this;
+}
+
+void AsyncArray::release() CV_NOEXCEPT
+{
+    Impl* impl = p;
+    p = NULL;
+    if (impl)
+        impl->releaseFuture();
+}
+
+bool AsyncArray::get(OutputArray dst, int64 timeoutNs) const
+{
+    CV_Assert(p);
+    return p->get(dst, timeoutNs);
+}
+
+void AsyncArray::get(OutputArray dst) const
+{
+    CV_Assert(p);
+    bool res = p->get(dst, -1);
+    CV_Assert(res);
+}
+
+bool AsyncArray::wait_for(int64 timeoutNs) const
+{
+    CV_Assert(p);
+    return p->wait_for(timeoutNs);
+}
+
+bool AsyncArray::valid() const CV_NOEXCEPT
+{
+    if (!p) return false;
+    return p->valid();
+}
+
+
+//
+// AsyncPromise
+//
+
+AsyncPromise::AsyncPromise() CV_NOEXCEPT
+    : p(new AsyncArray::Impl())
+{
+}
+
+AsyncPromise::~AsyncPromise() CV_NOEXCEPT
+{
+    release();
+}
+
+AsyncPromise::AsyncPromise(const AsyncPromise& o) CV_NOEXCEPT
+    : p(o.p)
+{
+    if (p)
+        p->addrefPromise();
+}
+
+AsyncPromise& AsyncPromise::operator=(const AsyncPromise& o) CV_NOEXCEPT
+{
+    Impl* newp = o.p;
+    if (newp)
+        newp->addrefPromise();
+    release();
+    p = newp;
+    return *this;
+}
+
+void AsyncPromise::release() CV_NOEXCEPT
+{
+    Impl* impl = p;
+    p = NULL;
+    if (impl)
+        impl->releasePromise();
+}
+
+AsyncArray AsyncPromise::getArrayResult()
+{
+    CV_Assert(p);
+    return p->getArrayResult();
+}
+
+void AsyncPromise::setValue(InputArray value)
+{
+    CV_Assert(p);
+    return p->setValue(value);
+}
+
+void AsyncPromise::setException(const cv::Exception& exception)
+{
+    CV_Assert(p);
+    return p->setException(exception);
+}
+
+#if CV__EXCEPTION_PTR
+void AsyncPromise::setException(std::exception_ptr exception)
+{
+    CV_Assert(p);
+    return p->setException(exception);
+}
+#endif
+
+} // namespace
diff -Nuarp opencv-4.12.0-orig/modules/core/src/bindings_utils.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/bindings_utils.cpp
--- opencv-4.12.0-orig/modules/core/src/bindings_utils.cpp	2025-07-13 06:04:01.162783458 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/bindings_utils.cpp	2025-07-13 06:09:23.173181013 +0000
@@ -22,7 +22,7 @@ String dumpInputArray(InputArray argumen
         return "InputArray: noArray()";
     std::ostringstream ss;
     ss << "InputArray:";
-    try {
+    {
         do {
             ss << (argument.empty() ? " empty()=true" : " empty()=false");
             ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
@@ -73,7 +73,7 @@ CV_EXPORTS_W String dumpInputArrayOfArra
         return "InputArrayOfArrays: noArray()";
     std::ostringstream ss;
     ss << "InputArrayOfArrays:";
-    try {
+    {
         do {
             ss << (argument.empty() ? " empty()=true" : " empty()=false");
             ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
@@ -130,7 +130,7 @@ CV_EXPORTS_W String dumpInputOutputArray
         return "InputOutputArray: noArray()";
     std::ostringstream ss;
     ss << "InputOutputArray:";
-    try {
+    {
         do {
             ss << (argument.empty() ? " empty()=true" : " empty()=false");
             ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
@@ -181,7 +181,7 @@ CV_EXPORTS_W String dumpInputOutputArray
         return "InputOutputArrayOfArrays: noArray()";
     std::ostringstream ss;
     ss << "InputOutputArrayOfArrays:";
-    try {
+    {
         do {
             ss << (argument.empty() ? " empty()=true" : " empty()=false");
             ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
diff -Nuarp opencv-4.12.0-orig/modules/core/src/bindings_utils.cpp.orig opencv-4.12.0-no-rtti-manual/modules/core/src/bindings_utils.cpp.orig
--- opencv-4.12.0-orig/modules/core/src/bindings_utils.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/bindings_utils.cpp.orig	2025-07-13 06:09:16.034149681 +0000
@@ -0,0 +1,289 @@
+// This file is part of OpenCV project.
+// It is subject to the license terms in the LICENSE file found in the top-level directory
+// of this distribution and at http://opencv.org/license.html.
+
+#include "precomp.hpp"
+#include "opencv2/core/bindings_utils.hpp"
+#include <sstream>
+#include <iomanip>
+#include <opencv2/core/utils/filesystem.hpp>
+#include <opencv2/core/utils/filesystem.private.hpp>
+
+namespace cv {
+static inline std::ostream& operator<<(std::ostream& os, const Rect& rect)
+{
+    return os << "[x=" << rect.x << ", y=" << rect.y << ", w=" << rect.width << ", h=" << rect.height << ']';
+}
+namespace utils {
+
+String dumpInputArray(InputArray argument)
+{
+    if (&argument == &noArray())
+        return "InputArray: noArray()";
+    std::ostringstream ss;
+    ss << "InputArray:";
+    try {
+        do {
+            ss << (argument.empty() ? " empty()=true" : " empty()=false");
+            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
+            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
+            if (argument.getObj() == NULL)
+            {
+                ss << " obj=NULL";
+                break; // done
+            }
+            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
+            int dims = argument.dims(-1);
+            ss << cv::format(" dims(-1)=%d", dims);
+            if (dims <= 2)
+            {
+                Size size = argument.size(-1);
+                ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
+            }
+            else
+            {
+                int sz[CV_MAX_DIM] = {0};
+                argument.sizend(sz, -1);
+                ss << " size(-1)=[";
+                for (int i = 0; i < dims; i++)
+                {
+                    if (i > 0)
+                        ss << ' ';
+                    ss << sz[i];
+                }
+                ss << "]";
+            }
+            ss << " type(-1)=" << cv::typeToString(argument.type(-1));
+        } while (0);
+    }
+    catch (const std::exception& e)
+    {
+        ss << " ERROR: exception occurred: " << e.what();
+    }
+    catch (...)
+    {
+        ss << " ERROR: unknown exception occurred, dump is non-complete";
+    }
+    return ss.str();
+}
+
+CV_EXPORTS_W String dumpInputArrayOfArrays(InputArrayOfArrays argument)
+{
+    if (&argument == &noArray())
+        return "InputArrayOfArrays: noArray()";
+    std::ostringstream ss;
+    ss << "InputArrayOfArrays:";
+    try {
+        do {
+            ss << (argument.empty() ? " empty()=true" : " empty()=false");
+            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
+            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
+            if (argument.getObj() == NULL)
+            {
+                ss << " obj=NULL";
+                break; // done
+            }
+            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
+            ss << cv::format(" dims(-1)=%d", argument.dims(-1));
+            Size size = argument.size(-1);
+            ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
+            if (argument.total(-1) > 0)
+            {
+                ss << " type(0)=" << cv::typeToString(argument.type(0));
+                int dims = argument.dims(0);
+                ss << cv::format(" dims(0)=%d", dims);
+                if (dims <= 2)
+                {
+                    Size size0 = argument.size(0);
+                    ss << cv::format(" size(0)=%dx%d", size0.width, size0.height);
+                }
+                else
+                {
+                    int sz[CV_MAX_DIM] = {0};
+                    argument.sizend(sz, 0);
+                    ss << " size(0)=[";
+                    for (int i = 0; i < dims; i++)
+                    {
+                        if (i > 0)
+                            ss << ' ';
+                        ss << sz[i];
+                    }
+                    ss << "]";
+                }
+            }
+        } while (0);
+    }
+    catch (const std::exception& e)
+    {
+        ss << " ERROR: exception occurred: " << e.what();
+    }
+    catch (...)
+    {
+        ss << " ERROR: unknown exception occurred, dump is non-complete";
+    }
+    return ss.str();
+}
+
+CV_EXPORTS_W String dumpInputOutputArray(InputOutputArray argument)
+{
+    if (&argument == &noArray())
+        return "InputOutputArray: noArray()";
+    std::ostringstream ss;
+    ss << "InputOutputArray:";
+    try {
+        do {
+            ss << (argument.empty() ? " empty()=true" : " empty()=false");
+            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
+            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
+            if (argument.getObj() == NULL)
+            {
+                ss << " obj=NULL";
+                break; // done
+            }
+            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
+            int dims = argument.dims(-1);
+            ss << cv::format(" dims(-1)=%d", dims);
+            if (dims <= 2)
+            {
+                Size size = argument.size(-1);
+                ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
+            }
+            else
+            {
+                int sz[CV_MAX_DIM] = {0};
+                argument.sizend(sz, -1);
+                ss << " size(-1)=[";
+                for (int i = 0; i < dims; i++)
+                {
+                    if (i > 0)
+                        ss << ' ';
+                    ss << sz[i];
+                }
+                ss << "]";
+            }
+            ss << " type(-1)=" << cv::typeToString(argument.type(-1));
+        } while (0);
+    }
+    catch (const std::exception& e)
+    {
+        ss << " ERROR: exception occurred: " << e.what();
+    }
+    catch (...)
+    {
+        ss << " ERROR: unknown exception occurred, dump is non-complete";
+    }
+    return ss.str();
+}
+
+CV_EXPORTS_W String dumpInputOutputArrayOfArrays(InputOutputArrayOfArrays argument)
+{
+    if (&argument == &noArray())
+        return "InputOutputArrayOfArrays: noArray()";
+    std::ostringstream ss;
+    ss << "InputOutputArrayOfArrays:";
+    try {
+        do {
+            ss << (argument.empty() ? " empty()=true" : " empty()=false");
+            ss << cv::format(" kind=0x%08llx", (long long int)argument.kind());
+            ss << cv::format(" flags=0x%08llx", (long long int)argument.getFlags());
+            if (argument.getObj() == NULL)
+            {
+                ss << " obj=NULL";
+                break; // done
+            }
+            ss << cv::format(" total(-1)=%lld", (long long int)argument.total(-1));
+            ss << cv::format(" dims(-1)=%d", argument.dims(-1));
+            Size size = argument.size(-1);
+            ss << cv::format(" size(-1)=%dx%d", size.width, size.height);
+            if (argument.total(-1) > 0)
+            {
+                ss << " type(0)=" << cv::typeToString(argument.type(0));
+                int dims = argument.dims(0);
+                ss << cv::format(" dims(0)=%d", dims);
+                if (dims <= 2)
+                {
+                    Size size0 = argument.size(0);
+                    ss << cv::format(" size(0)=%dx%d", size0.width, size0.height);
+                }
+                else
+                {
+                    int sz[CV_MAX_DIM] = {0};
+                    argument.sizend(sz, 0);
+                    ss << " size(0)=[";
+                    for (int i = 0; i < dims; i++)
+                    {
+                        if (i > 0)
+                            ss << ' ';
+                        ss << sz[i];
+                    }
+                    ss << "]";
+                }
+            }
+        } while (0);
+    }
+    catch (const std::exception& e)
+    {
+        ss << " ERROR: exception occurred: " << e.what();
+    }
+    catch (...)
+    {
+        ss << " ERROR: unknown exception occurred, dump is non-complete";
+    }
+    return ss.str();
+}
+
+template <class T, class Formatter>
+static inline String dumpVector(const std::vector<T>& vec, Formatter format)
+{
+    std::ostringstream oss("[", std::ios::ate);
+    if (!vec.empty())
+    {
+        format(oss) << vec[0];
+        for (std::size_t i = 1; i < vec.size(); ++i)
+        {
+            oss << ", ";
+            format(oss) << vec[i];
+        }
+    }
+    oss << "]";
+    return oss.str();
+}
+
+static inline std::ostream& noFormat(std::ostream& os)
+{
+    return os;
+}
+
+static inline std::ostream& floatFormat(std::ostream& os)
+{
+    return os << std::fixed << std::setprecision(2);
+}
+
+String dumpVectorOfInt(const std::vector<int>& vec)
+{
+    return dumpVector(vec, &noFormat);
+}
+
+String dumpVectorOfDouble(const std::vector<double>& vec)
+{
+    return dumpVector(vec, &floatFormat);
+}
+
+String dumpVectorOfRect(const std::vector<Rect>& vec)
+{
+    return dumpVector(vec, &noFormat);
+}
+
+
+namespace fs {
+cv::String getCacheDirectoryForDownloads()
+{
+#if OPENCV_HAVE_FILESYSTEM_SUPPORT
+    return cv::utils::fs::getCacheDirectory("downloads", "OPENCV_DOWNLOADS_CACHE_DIR");
+#else
+    CV_Error(Error::StsNotImplemented, "File system support is disabled in this OpenCV build!");
+#endif
+}
+} // namespace fs
+
+}} // namespace
diff -Nuarp opencv-4.12.0-orig/modules/core/src/bindings_utils.cpp.rej opencv-4.12.0-no-rtti-manual/modules/core/src/bindings_utils.cpp.rej
--- opencv-4.12.0-orig/modules/core/src/bindings_utils.cpp.rej	1970-01-01 00:00:00.000000000 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/bindings_utils.cpp.rej	2025-07-13 06:09:23.173181013 +0000
@@ -0,0 +1,46 @@
+--- modules/core/src/bindings_utils.cpp	2025-03-23 14:08:46.699988132 +0800
++++ modules/core/src/bindings_utils.cpp	2025-03-23 14:09:34.499350445 +0800
+@@ -51,10 +51,6 @@ String dumpInputArray(InputArray argumen
+             ss << " type(-1)=" << cv::typeToString(argument.type(-1));
+         } while (0);
+     }
+-    catch (...)
+-    {
+-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
+-    }
+     return ss.str();
+ }
+ 
+@@ -104,10 +100,6 @@ CV_EXPORTS_W String dumpInputArrayOfArra
+             }
+         } while (0);
+     }
+-    catch (...)
+-    {
+-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
+-    }
+     return ss.str();
+ }
+ 
+@@ -151,10 +143,6 @@ CV_EXPORTS_W String dumpInputOutputArray
+             ss << " type(-1)=" << cv::typeToString(argument.type(-1));
+         } while (0);
+     }
+-    catch (...)
+-    {
+-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
+-    }
+     return ss.str();
+ }
+ 
+@@ -204,10 +192,6 @@ CV_EXPORTS_W String dumpInputOutputArray
+             }
+         } while (0);
+     }
+-    catch (...)
+-    {
+-        ss << " ERROR: exception occurred, dump is non-complete";  // need to properly support different kinds
+-    }
+     return ss.str();
+ }
+ 
diff -Nuarp opencv-4.12.0-orig/modules/core/src/command_line_parser.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/command_line_parser.cpp
--- opencv-4.12.0-orig/modules/core/src/command_line_parser.cpp	2025-07-13 06:04:01.162783458 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/command_line_parser.cpp	2025-07-13 06:09:23.173181013 +0000
@@ -119,7 +119,6 @@ static void from_str(const String& str,
 
 void CommandLineParser::getByName(const String& name, bool space_delete, Param type, void* dst) const
 {
-    try
     {
         for (size_t i = 0; i < impl->data.size(); i++)
         {
@@ -144,12 +143,6 @@ void CommandLineParser::getByName(const
             }
         }
     }
-    catch (const Exception& e)
-    {
-        impl->error = true;
-        impl->error_message = impl->error_message + "Parameter '"+ name + "': " + e.err + "\n";
-        return;
-    }
 
     CV_Error_(Error::StsBadArg, ("undeclared key '%s' requested", name.c_str()));
 }
@@ -157,7 +150,6 @@ void CommandLineParser::getByName(const
 
 void CommandLineParser::getByIndex(int index, bool space_delete, Param type, void* dst) const
 {
-    try
     {
         for (size_t i = 0; i < impl->data.size(); i++)
         {
@@ -177,12 +169,6 @@ void CommandLineParser::getByIndex(int i
             }
         }
     }
-    catch (const Exception& e)
-    {
-        impl->error = true;
-        impl->error_message = impl->error_message + format("Parameter #%d: ", index) + e.err + "\n";
-        return;
-    }
 
     CV_Error_(Error::StsBadArg, ("undeclared position %d requested", index));
 }
@@ -464,16 +450,7 @@ std::vector<String> CommandLineParser::I
         {
             if (begin == true)
             {
-                throw cv::Exception(cv::Error::StsParseError,
-                         String("error in split_range_string(")
-                         + str
-                         + String(", ")
-                         + String(1, fs)
-                         + String(", ")
-                         + String(1, ss)
-                         + String(")"),
-                         "", __FILE__, __LINE__
-                         );
+                return vec;
             }
             begin = true;
             word = "";
@@ -484,16 +461,7 @@ std::vector<String> CommandLineParser::I
         {
             if (begin == false)
             {
-                throw cv::Exception(cv::Error::StsParseError,
-                         String("error in split_range_string(")
-                         + str
-                         + String(", ")
-                         + String(1, fs)
-                         + String(", ")
-                         + String(1, ss)
-                         + String(")"),
-                         "", __FILE__, __LINE__
-                         );
+                return vec;
             }
             begin = false;
             vec.push_back(word);
@@ -508,16 +476,7 @@ std::vector<String> CommandLineParser::I
 
     if (begin == true)
     {
-        throw cv::Exception(cv::Error::StsParseError,
-                 String("error in split_range_string(")
-                 + str
-                 + String(", ")
-                 + String(1, fs)
-                 + String(", ")
-                 + String(1, ss)
-                 + String(")"),
-                 "", __FILE__, __LINE__
-                );
+        return vec;
     }
 
     return vec;
diff -Nuarp opencv-4.12.0-orig/modules/core/src/glob.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/glob.cpp
--- opencv-4.12.0-orig/modules/core/src/glob.cpp	2025-07-13 06:04:01.163783462 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/glob.cpp	2025-07-13 06:09:23.173181013 +0000
@@ -243,7 +243,6 @@ static void glob_rec(const cv::String& d
     if ((dir = opendir (directory.c_str())) != 0)
     {
         /* find all the files and directories within directory */
-        try
         {
             struct dirent *ent;
             while ((ent = readdir (dir)) != 0)
@@ -267,11 +266,6 @@ static void glob_rec(const cv::String& d
                     result.push_back(entry);
             }
         }
-        catch (...)
-        {
-            closedir(dir);
-            throw;
-        }
         closedir(dir);
     }
     else
diff -Nuarp opencv-4.12.0-orig/modules/core/src/matrix.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/matrix.cpp
--- opencv-4.12.0-orig/modules/core/src/matrix.cpp	2025-07-13 06:04:01.164783466 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/matrix.cpp	2025-07-13 06:09:23.173181013 +0000
@@ -694,20 +694,11 @@ void Mat::create(int d, const int* _size
         MatAllocator *a = allocator, *a0 = getDefaultAllocator();
         if(!a)
             a = a0;
-        try
         {
             u = a->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, USAGE_DEFAULT);
             CV_Assert(u != 0);
             allocator = a;
         }
-        catch (...)
-        {
-            if (a == a0)
-                throw;
-            u = a0->allocate(dims, size, _type, 0, step.p, ACCESS_RW /* ignored */, USAGE_DEFAULT);
-            CV_Assert(u != 0);
-            allocator = a0;
-        }
         CV_Assert( step[dims-1] == (size_t)CV_ELEM_SIZE(flags) );
     }
 
@@ -757,7 +748,6 @@ Mat::Mat(const Mat& m, const Range& _row
     }
 
     *this = m;
-    try
     {
         if( _rowRange != Range::all() && _rowRange != Range(0,rows) )
         {
@@ -777,11 +767,6 @@ Mat::Mat(const Mat& m, const Range& _row
             flags |= SUBMATRIX_FLAG;
         }
     }
-    catch(...)
-    {
-        release();
-        throw;
-    }
 
     updateContinuityFlag();
 
diff -Nuarp opencv-4.12.0-orig/modules/core/src/parallel/parallel.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/parallel/parallel.cpp
--- opencv-4.12.0-orig/modules/core/src/parallel/parallel.cpp	2025-07-13 06:04:01.168783487 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/parallel/parallel.cpp	2025-07-13 06:09:23.174181017 +0000
@@ -60,7 +60,6 @@ std::shared_ptr<ParallelForAPI> createPa
             }
             isKnown = true;
         }
-        try
         {
             CV_LOG_DEBUG(NULL, "core(parallel): trying backend: " << info.name << " (priority=" << info.priority << ")");
             if (!info.backendFactory)
@@ -79,14 +78,6 @@ std::shared_ptr<ParallelForAPI> createPa
             getParallelBackendName() = info.name;
             return backend;
         }
-        catch (const std::exception& e)
-        {
-            CV_LOG_WARNING(NULL, "core(parallel): can't initialize " << info.name << " backend: " << e.what());
-        }
-        catch (...)
-        {
-            CV_LOG_WARNING(NULL, "core(parallel): can't initialize " << info.name << " backend: Unknown C++ exception");
-        }
     }
     if (name.empty())
     {
diff -Nuarp opencv-4.12.0-orig/modules/core/src/parallel/plugin_parallel_wrapper.impl.hpp opencv-4.12.0-no-rtti-manual/modules/core/src/parallel/plugin_parallel_wrapper.impl.hpp
--- opencv-4.12.0-orig/modules/core/src/parallel/plugin_parallel_wrapper.impl.hpp	2025-07-13 06:04:01.168783487 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/parallel/plugin_parallel_wrapper.impl.hpp	2025-07-13 06:09:23.174181017 +0000
@@ -155,15 +155,10 @@ protected:
     void initBackend()
     {
         AutoLock lock(getInitializationMutex());
-        try
         {
             if (!initialized)
                 loadPlugin();
         }
-        catch (...)
-        {
-            CV_LOG_INFO(NULL, "core(parallel): exception during plugin loading: " << baseName_ << ". SKIP");
-        }
         initialized = true;
     }
     void loadPlugin();
@@ -243,7 +238,6 @@ void PluginParallelBackendFactory::loadP
         {
             continue;
         }
-        try
         {
             auto pluginBackend = std::make_shared<PluginParallelBackend>(lib);
             if (!pluginBackend)
@@ -264,10 +258,6 @@ void PluginParallelBackendFactory::loadP
             backend = pluginBackend;
             return;
         }
-        catch (...)
-        {
-            CV_LOG_WARNING(NULL, "core(parallel): exception during plugin initialization: " << toPrintablePath(plugin) << ". SKIP");
-        }
     }
 }
 
diff -Nuarp opencv-4.12.0-orig/modules/core/src/parallel.cpp opencv-4.12.0-no-rtti-manual/modules/core/src/parallel.cpp
--- opencv-4.12.0-orig/modules/core/src/parallel.cpp	2025-07-13 06:04:01.167783482 +0000
+++ opencv-4.12.0-no-rtti-manual/modules/core/src/parallel.cpp	2025-07-13 06:09:23.174181017 +0000
@@ -355,29 +355,9 @@ namespace {
             CV_TRACE_ARG_VALUE(range_end, "range.end", (int64)r.end);
 #endif
 
-            try
             {
                 (*ctx.body)(r);
             }
-#if CV__EXCEPTION_PTR
-            catch (...)
-            {
-                ctx.recordException();
-            }
-#else
-            catch (const cv::Exception& e)
-            {
-                ctx.recordException(e.what());
-            }
-            catch (const std::exception& e)
-            {
-                ctx.recordException(e.what());
-            }
-            catch (...)
-            {
-                ctx.recordException("Unknown exception");
-            }
-#endif
 
             if (!ctx.is_rng_used && !(cv::theRNG() == ctx.rng))
                 ctx.is_rng_used = true;
@@ -523,16 +503,10 @@ void parallel_for_(const cv::Range& rang
       isNotNestedRegion = !flagNestedParallelFor.exchange(true);
     if (isNotNestedRegion)
     {
-        try
         {
             parallel_for_impl(range, body, nstripes);
             flagNestedParallelFor = false;
         }
-        catch (...)
-        {
-            flagNestedParallelFor = false;
-            throw;
-        }
     }
     else // nested parallel_for_() calls are not parallelized
     {
